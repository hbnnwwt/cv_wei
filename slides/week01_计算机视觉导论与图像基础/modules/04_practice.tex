%=============================================================================
% 模块四：核心算法与实战演练
%=============================================================================

\section{图像滤镜原理}

\begin{frame}[fragile]{滤镜 1：灰度化 (Grayscale)}
	\textbf{为什么要灰度化？}
	\begin{itemize}
		\item 减少计算量（数据量降至 1/3）
		\item 识别试卷上的文字，颜色信息通常是不必要的
	\end{itemize}
	\textbf{原理：} $Gray = R \times 0.299 + G \times 0.587 + B \times 0.114$
	\\ (为什么绿色权重最高？因为人眼对绿色最敏感。)

	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\small]
# 方法1：OpenCV 函数
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 方法2：手动计算（不推荐）
gray = 0.299 * r + 0.587 * g + 0.114 * b
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{滤镜 2：反色 (Inversion)}
	\textbf{原理：} $NewValue = 255 - OldValue$
	\begin{itemize}
		\item 黑色 (0) $\to$ 白色 (255)
		\item 白色 (255) $\to$ 黑色 (0)
	\end{itemize}
	\textbf{应用：} 增强暗背景下的试卷特征，或者扫描负片。

	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\small]
# 方法1：NumPy 运算
inverted = 255 - img

# 方法2：OpenCV 位运算
inverted = cv2.bitwise_not(img)

# 方法3：NumPy 按位取反
inverted = np.bitwise_not(img)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{滤镜 3：亮度调整与"溢出"陷阱}
	\textbf{错误做法：} \texttt{img + 50}
	\\ 如果像素值是 220，加 50 变成 270。而在 \texttt{uint8} 类型下，270 会变成 \highlight{14} (截断/绕回)，导致图像出现难看的噪点。

	\begin{lstlisting}[title={安全写法}]
# 使用 numpy 的 clip 函数限制范围
bright_img = np.clip(img.astype(np.int32) + 50, 0, 255).astype(np.uint8)

# 或者使用 OpenCV 内置函数（推荐，速度更快）
bright_img = cv2.add(img, np.array([50.0]))
\end{lstlisting}
\end{frame}

% -----------------------------------------------------------------------------
% 代码实战环节
% -----------------------------------------------------------------------------

\section{代码实战}

\begin{frame}[fragile]{代码实战（1/5）：图像翻转与旋转}
	\textbf{场景：}阅卷时试卷可能被倒置，需要自动旋转

	\begin{columns}
		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
import cv2
import numpy as np

img = cv2.imread('exam.jpg')

# 方法1：NumPy 数组切片
# 垂直翻转（上下颠倒）
flip_v = img[::-1, :, :]

# 水平翻转（左右颠倒）
flip_h = img[:, ::-1, :]

# 水平+垂直翻转（旋转180度）
flip_both = img[::-1, ::-1, :]
\end{lstlisting}

		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
# 方法2：OpenCV 函数（推荐）
flip_v = cv2.flip(img, 0)      # 垂直
flip_h = cv2.flip(img, 1)      # 水平
flip_both = cv2.flip(img, -1)  # 两者

# 显示对比
cv2.imshow('Original', img)
cv2.imshow('Flip V', flip_v)
cv2.imshow('Flip H', flip_h)
cv2.waitKey(0)
\end{lstlisting}
	\end{columns}

	\vspace{0.2cm}
	\textbf{性能对比：} NumPy 切片比 cv2.flip 快约 20\%，但 cv2.flip 更易读
\end{frame}

\begin{frame}[fragile]{代码实战（2/5）：提取答题卡区域（ROI）}
	\textbf{场景：}从整张试卷中提取答题卡区域

	\begin{columns}
		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
import cv2
import numpy as np

exam = cv2.imread('exam.jpg')
h, w = exam.shape[:2]

# 假设答题卡在右下角
# 坐标：从宽度的60%到末尾，高度的50%到末尾
x1, x2 = int(w * 0.6), w
y1, y2 = int(h * 0.5), h

# 提取 ROI
roi = exam[y1:y2, x1:x2]

# 保存 ROI
cv2.imwrite('answer_sheet.jpg', roi)

print("原图大小:", exam.shape)
print("ROI 大小:", roi.shape)
\end{lstlisting}

		\column{0.5\textwidth}
		\textbf{坐标系统回顾：}
		\begin{itemize}
			\item 原点在左上角 (0, 0)
			\item \texttt{img[y1:y2, x1:x2]}
			\item y 是行（高度），x 是列（宽度）
		\end{itemize}

		\vspace{0.3cm}
		\begin{center}
			\begin{tikzpicture}[scale=0.4]
				\draw[thick, fill=blue!10] (0,0) rectangle (6,4);
				\node at (3,2) {整张试卷};
				\draw[thick, fill=red!30] (3.5,0) rectangle (6,2);
				\node at (4.75,1) {\tiny ROI};
				\draw[->] (3.5,2) -- (3.5,3) node[above] {\tiny y1};
				\draw[->] (3.5,0) -- (3.5,-1) node[below] {\tiny y2};
				\draw[->] (3.5,1) -- (2.5,1) node[left] {\tiny x1};
				\draw[->] (6,1) -- (7,1) node[right] {\tiny x2};
			\end{tikzpicture}
		\end{center}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{代码实战（3/5）：通道分离与合并}
	\textbf{场景：}提取特定颜色通道

	\begin{columns}
		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
import cv2

img = cv2.imread('exam.jpg')

# 方法1：使用 split 函数
b, g, r = cv2.split(img)

# 只保留红色通道，其他设为0
zeros = np.zeros_like(b)
img_r = cv2.merge([zeros, zeros, r])
\end{lstlisting}

		\vspace{0.2cm}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
# 方法2：直接索引（更快）
img_r = img.copy()
img_r[:, :, 0] = 0  # B通道
img_r[:, :, 1] = 0  # G通道
# R通道保持不变

cv2.imshow('Red Only', img_r)
cv2.waitKey(0)
\end{lstlisting}

		\column{0.5\textwidth}
		\textbf{通道顺序：}
		\begin{itemize}
			\item OpenCV: \textbf{BGR}
			\item matplotlib: \textbf{RGB}
			\item PIL: \textbf{RGB}
		\end{itemize}

		\vspace{0.3cm}
		\begin{alertblock}{常见错误}
			使用 \texttt{plt.imshow(img)} 显示 OpenCV 图像时，颜色会异常！
		\end{alertblock}

		\vspace{0.2cm}
		\textbf{解决方案：}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img_rgb)
\end{lstlisting}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{代码实战（4/5）：阅卷系统核心代码}
	\textbf{场景：}检测答题卡填涂位置

	\begin{columns}
		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
import cv2
import numpy as np

# 1. 读取答题卡区域
roi = cv2.imread('answer_sheet.jpg',
                 cv2.IMREAD_GRAYSCALE)

# 2. 二值化
_, binary = cv2.threshold(roi, 127, 255,
                          cv2.THRESH_BINARY)

# 3. 定义选项位置
positions = [
    (100, 100, 120, 120),  # A
    (100, 130, 120, 150),  # B
    (100, 160, 120, 180),  # C
    (100, 190, 120, 200)   # D
]
\end{lstlisting}

		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
# 4. 检测每个选项是否被填涂
answers = []
for (x1, y1, x2, y2) in positions:
    option = binary[y1:y2, x1:x2]

    # 计算黑色像素比例
    black_pixels = np.sum(option == 0)
    total_pixels = option.size
    ratio = black_pixels / total_pixels

    # 判断是否填涂（阈值30%）
    if ratio > 0.3:
        answers.append('填涂')
    else:
        answers.append('未填')

print(answers)
\end{lstlisting}
	\end{columns}

	\vspace{0.2cm}
	\textbf{核心思想：}填涂区域黑色像素占比显著高于未填涂区域
\end{frame}

\begin{frame}[fragile]{代码实战（5/5）：图像增强对比}
	\textbf{场景：}答题卡光照不均，需要增强对比度

	\begin{columns}
		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
import cv2
import numpy as np

img = cv2.imread('exam.jpg')

# 方法1：线性对比度调整
# new = alpha * old + beta
enhanced = cv2.convertScaleAbs(
    img, alpha=1.5, beta=30
)
\end{lstlisting}

		\vspace{0.2cm}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
# 方法2：直方图均衡化
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
equalized = cv2.equalizeHist(gray)
\end{lstlisting}

		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
# 方法3：CLAHE（自适应）
clahe = cv2.createCLAHE(
    clipLimit=2.0,
    tileGridSize=(8,8)
)
enhanced_clahe = clahe.apply(gray)
\end{lstlisting}

		\vspace{0.2cm}
		\textbf{效果对比：}
		\begin{itemize}
			\item \textbf{线性调整}：简单但效果有限
			\item \textbf{直方图均衡化}：全局优化
			\item \textbf{CLAHE}：局部自适应，效果最好
		\end{itemize}

		\vspace{0.2cm}
		\textbf{阅卷推荐：} CLAHE 适合光照不均场景
	\end{columns}
\end{frame}

% -----------------------------------------------------------------------------
% 完整阅卷系统Live Coding
% -----------------------------------------------------------------------------

\begin{frame}[fragile]{Live Coding：完整的阅卷预处理流程}
	\textbf{目标：} 从照片到可识别的图像

	\begin{columns}
		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
def preprocess_exam(image_path):
    """试卷预处理完整流程"""

    # 1. 读取图像（支持中文路径）
    img = imread_chinese(image_path)

    # 2. 转为灰度
    gray = cv2.cvtColor(img,
                       cv2.COLOR_BGR2GRAY)

    # 3. 去噪
    denoised = cv2.GaussianBlur(
        gray, (5, 5), 0)

    # 4. 对比度增强（CLAHE）
    clahe = cv2.createCLAHE(2.0, (8, 8))
    enhanced = clahe.apply(denoised)

    # 5. 二值化
    binary = cv2.adaptiveThreshold(
        enhanced, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY, 11, 2)

    return img, gray, enhanced, binary

# 使用
img, gray, enhanced, binary = \
    preprocess_exam('exam.jpg')
		\end{lstlisting}

		\column{0.5\textwidth}
		\textbf{流程图：}
		\begin{center}
			\begin{tikzpicture}[scale=0.6, node distance=0.8cm]
				\node[draw, rounded corners] (1) {原图};
				\node[draw, rounded corners, below of=1] (2) {灰度};
				\node[draw, rounded corners, below of=2] (3) {去噪};
				\node[draw, rounded corners, below of=3] (4) {增强};
				\node[draw, rounded corners, below of=4] (5) {二值};

				\draw[->] (1) -- (2);
				\draw[->] (2) -- (3);
				\draw[->] (3) -- (4);
				\draw[->] (4) -- (5);
			\end{tikzpicture}
		\end{center}

		\vspace{0.2cm}
		\textbf{展示结果：}
		\begin{itemize}
			\item 原始照片
			\item 预处理后图像
			\item 处理时间对比
		\end{itemize}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Live Coding：阅卷系统核心检测}
	\textbf{功能1：填涂检测}
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
def detect_bubble(binary, position):
    """检测单个气泡的填涂状态"""
    x1, y1, x2, y2 = position

    # 提取气泡区域
    bubble = binary[y1:y2, x1:x2]

    # 计算填涂密度
    black_pixels = np.sum(bubble == 0)
    total_pixels = bubble.size
    fill_ratio = black_pixels / total_pixels

    # 判断状态
    if fill_ratio > 0.6:
        return 'filled'
    elif fill_ratio < 0.2:
        return 'empty'
    else:
        return 'uncertain'
	\end{lstlisting}

	\vspace{0.2cm}
	\textbf{功能2：多选检测与警告}
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
def detect_multiple_choice(binary, positions):
    """检测多选并警告"""
    results = []
    for pos in positions:
        state = detect_bubble(binary, pos)
        results.append(state)

    # 统计填涂数量
    filled_count = sum(1 for r in results if r == 'filled')

    if filled_count > 1:
        print(f"警告：检测到多选（{filled_count}个选项）")

    return results
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Live Coding：图像质量检测函数}
	\textbf{目标：} 自动判断试卷照片是否适合识别

	\begin{columns}
		\column{0.5\textwidth}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
def check_image_quality(img):
    """检测图像质量"""

    h, w = img.shape[:2]

    # 1. 分辨率检查
    if min(h, w) < 1000:
        return False, "分辨率过低"

    # 2. 曝光检查
    gray = cv2.cvtColor(img,
                       cv2.COLOR_BGR2GRAY)
    mean_brightness = np.mean(gray)

    if mean_brightness < 80:
        return False, "曝光不足"
    elif mean_brightness > 200:
        return False, "过曝"

    # 3. 清晰度检查
    laplacian_var = cv2.Laplacian(
        gray, cv2.CV_64F
    ).var()

    if laplacian_var < 100:
        return False, "图像模糊"

    return True, "质量合格"
		\end{lstlisting}

		\column{0.5\textwidth}
		\textbf{使用示例：}
		\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
img = imread_chinese('exam.jpg')

is_good, msg = check_image_quality(img)

if is_good:
    print(f"图像质量：{msg}")
    # 继续处理
    result = process_image(img)
else:
    print(f"图像质量：{msg}")
    print("提示用户重新拍照")
		\end{lstlisting}

		\vspace{0.2cm}
		\textbf{质量标准：}
		\begin{itemize}
			\item 分辨率：≥1000px
			\item 曝光：80-200
			\item 清晰度：Laplacian方差 ≥100
		\end{itemize}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Live Coding：批量处理与结果输出}
	\textbf{批量处理函数：}
	\begin{lstlisting}[language=Python, basicstyle=\ttfamily\tiny]
import os
import json

def batch_process_exams(folder_path, output_path):
    """批量处理试卷"""
    results = []

    for filename in os.listdir(folder_path):
        if not filename.endswith(('.jpg', '.png')):
            continue

        input_path = os.path.join(folder_path, filename)

        # 1. 质量检查
        is_good, msg = check_image_quality(
            imread_chinese(input_path))
        if not is_good:
            print(f"X {filename}: {msg}")
            continue

        # 2. 预处理
        img, gray, enhanced, binary = \
            preprocess_exam(input_path)

        # 3. 检测答题
        answers = detect_all_answers(binary)

        # 4. 评分
        score, details = grade_answers(answers)

        # 5. 保存结果
        result = {
            'filename': filename,
            'score': score,
            'details': details,
            'quality': is_good
        }
        results.append(result)

        print(f"OK {filename}: {score}分")

    # 保存到JSON
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(results, f, ensure_ascii=False, indent=2)

    return results
	\end{lstlisting}
\end{frame}
